/**
 * Event Story Translation Loader
 * Loads per-event translation files from /data/translations/eventStory/
 * 
 * Translation files are generated by the server-side translate.py script
 * and contain CN translations for each episode's TalkData.
 */

// Translation data structure for a single event
export interface IEpisodeTranslation {
    scenarioId: string;
    title?: string;
    talkData: Record<string, string>;
}

export interface IEventStoryTranslation {
    meta?: {
        source: 'official_cn' | 'llm';
        version: string;
        last_updated: number;
    };
    episodes: Record<string, IEpisodeTranslation>;
}

// Map: eventId -> translation data
const translationCache = new Map<number, IEventStoryTranslation | null>();

// Track in-flight requests to prevent duplicate fetches
const inflightRequests = new Map<number, Promise<IEventStoryTranslation | null>>();

/**
 * Load event story translation for a specific event
 * Returns cached data if available, otherwise fetches from server
 * 
 * @param eventId - The event ID
 * @returns Translation data or null if not available
 */
export async function loadEventStoryTranslation(eventId: number): Promise<IEventStoryTranslation | null> {
    // Return cached data if available
    if (translationCache.has(eventId)) {
        return translationCache.get(eventId)!;
    }

    // If already loading, wait for that promise
    if (inflightRequests.has(eventId)) {
        return inflightRequests.get(eventId)!;
    }

    // Start loading
    const loadPromise = (async (): Promise<IEventStoryTranslation | null> => {
        try {
            const response = await fetch(`/data/translations/eventStory/event_${eventId}.json`);
            if (!response.ok) {
                // Translation file doesn't exist for this event
                translationCache.set(eventId, null);
                return null;
            }
            const data = await response.json();

            // Backward compatibility: check if data has "episodes" key
            let parsedData: IEventStoryTranslation;
            if (data.episodes) {
                parsedData = data as IEventStoryTranslation;
            } else {
                // Treat as old format (just episodes map)
                // Assume it's official_cn since that was the only source using this loader before
                parsedData = {
                    meta: { source: 'official_cn', version: '0.0', last_updated: 0 },
                    episodes: data as Record<string, IEpisodeTranslation>
                };
            }

            translationCache.set(eventId, parsedData);
            return parsedData;
        } catch (error) {
            console.debug(`Event story translation not found for event ${eventId}:`, error);
            translationCache.set(eventId, null);
            return null;
        } finally {
            inflightRequests.delete(eventId);
        }
    })();

    inflightRequests.set(eventId, loadPromise);
    return loadPromise;
}

/**
 * Get translation for a specific text
 * 
 * @param translation - The event story translation data
 * @param episodeNo - The episode number
 * @returns The Chinese translation or undefined if not found
 */
export function getStoryTranslation(
    translation: IEventStoryTranslation | null,
    episodeNo: number
): IEpisodeTranslation | null {
    if (!translation) return null;
    return translation.episodes[episodeNo.toString()] || null;
}

/**
 * Clear the translation cache (useful for testing or forced refresh)
 */
export function clearEventStoryTranslationCache(): void {
    translationCache.clear();
    inflightRequests.clear();
}
